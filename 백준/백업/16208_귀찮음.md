### 

### 풀이 흐름

첫번째 테스트케이스에서 자르는 방식을 다르게 해서 세가지 경우를 계산해봤는데 답이 모두 똑같았다.

이 테스트케이스가 특이한 경우인가? 라는 생각이 먼저 들었다.

하지만 일반화된 식으로 바꿔보면 숫자가 a1, a2, a3, a4로 주어질 때,

1번 경우) a1*(a2+a3+a4) + a2*(a3+a4) + a3*a4 = a1*a2 + a1*a3+a1*a4 + a2*a3+ a2*a4 + a3*a4

2번 경우) (a1+a2)*(a3+a4) + a1*a2 + a3*a4 = a1*a3+a1*a4+a2*a3+a2*a4+a1*a2+a3*a4

어떻게 자르든 결과는 같다는 것을 깨달았다.

자르는 순서는 상관없으니 그냥 앞에서 주어진 숫자부터 하나씩 자르도록 구현했다.

그리고 이중 for문으로 남은 막대길이를 매번 더해서 구하면 시간적 측면에서 비효율적이기 때문에

처음부터 총 막대 길이를 구한 후 자른 막대 길이만큼 빼주고 재할당하는 식으로 구현했다.

### 

### 어려웠던 점

SWEA 위주로 문제를 풀다가 백준 문제를 풀어보니 단순히 문제에서 요구하는 출력값만 구하는 것이 아니라 시간, 메모리 효율성까지 고려해야하는 문제들이 많았다. 지금까지는 재귀를 제외하고는 시간적 측면을 고려해본 적이 없어서 어떻게 하면 시간을 줄일 수 있는지 잘 모르겠다.

### 

### 느낀 점

1. 무작정 모든 경우의 수를 구하는 코딩을 하지않고 규칙을 찾고 구현해서 뿌듯하다.

2. 알고리즘 문제에서 수학적 사고력을 요구하는 경우가 있는데 수학공부도 해야하나... 싶다...
